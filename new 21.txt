Q1. Matches of the League
SQL
Unsolved
feature icon

Problem Statement:

Write a query that reports all the possible matches of the league.

Note that every two teams play two matches with each other, with one team being the home_team once and the other time being the away_team.
Return the result table ordered by home_team and away_team in an ascending manner.
=============================================
select p.team_name as home_team,
       q.team_name as away_team
from teams p
cross join teams q
where p.team_name!=q.team_name
order by home_team, away_team

========================================

Q6. Department wise salary analysis
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Write a query to calculate

the row number and save it as 'emp_row_no',
rank and save as 'emp_rank', and
the dense rank of employees as 'emp_dense_rank'
based on the salary column in descending order within each department using the employees table.

Return the columns 'full_name' (first_name and last_name separated by space), 'department_id', 'salary', 'emp_row_no', 'emp_rank', and 'emp_dense_rank'.
Return the result ordered by department_id in ascending order and salary in descending order.
=====================================================
select concat(first_name,' ',last_name) as full_name,
       department_id,salary,
       row_number() over(partition by department_id order by salary desc) as emp_row_no,
       rank() over(partition by department_id order by salary desc) as emp_rank,
       dense_rank() over(partition by department_id order by salary desc) as emp_dense_rank
       from employees
       order by department_id, salary desc


==========================================================
Q4. 5th highest
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Write a query to display the details of the employees who have the 5th highest salary in each job category.

Return the columns 'employee_id', 'first_name', and 'job_id'.
Return the result ordered by employee_id in ascending order.
===========================================
select employee_id,first_name,job_id
from (select *, 
            dense_rank() over(partition by job_id order by salary desc) as dense_rnk
            from employees) a
where dense_rnk =5
order by employee_id  


===============================================
Q7. Salaries after taxes
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Description:

Write a query to find the salaries of the employees after applying taxes. Round the salary to the nearest integer.

The tax rate is calculated for each company based on the following criteria:

0% If the max salary of any employee in the company is less than $1000.
24% If the max salary of any employee in the company is in the range [1000, 10000] inclusive.
49% If the max salary of any employee in the company is greater than $10000.
The salary after taxes = salary - salary x (taxes percentage / 100).
Return the result ordered by company_id, and employee_id in ascending order.
==================================================================
select company_id,employee_id,employee_name,
round(case when max(salary) over(partition by company_id) < 1000 
      then salary
      when max(salary) over(partition by company_id) BETWEEN 1000 AND 10000 
      then salary - (salary * 0.24)
      else salary - (salary * 0.49)
      end, 0) as salary
      from salaries
order by company_id, employee_id


======================================================

Q3. Order Two Columns Independently
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Write a query to independently:

order first_col in ascending order.
order second_col in descending order.

========================================================
select a.first_col, b.second_col
from(select first_col,
            row_number() over(order by first_col asc) as rnum
            from data) a
inner join(select second_col,
           row_number() over(order by second_col desc) as rnum
           from data) b
on a.rnum=b.rnum

=============================================================
Q2. Second Degree Follower
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

A second-degree follower is a user who:

follows at least one user, and
is followed by at least one user.
Write a query to report the second-degree users and the number of their followers.

Return the result table ordered by follower in alphabetical order.
================================================================
SELECT f1.follower, count(distinct f2.follower) as num 
 FROM follow f1 
 INNER JOIN follow f2 ON f1.follower = f2.followee 
 GROUP BY f1.follower 
 ORDER BY f1.follower 

=======================================================================
Q5. Ranks for Scores
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Write a query to rank the scores. The ranking should be calculated according to the following rules:

The scores should be ranked from the highest to the lowest.
If there is a tie between two scores, both should have the same ranking.
After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.
Note: Return the result table ordered by score in descending order.
=======================================================================
select score,
       dense_rank() over(order by score desc) as 'rank'
       from scores
       order by score desc
=====================================================================
Q1. Less salary
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Find the details of the employees who earn less than the average salary in their respective departments.

Note:

Return the columns 'employee_id', 'first_name', 'last_name', 'department_id', and 'salary'.
Return the output ordered by employee_id in ascending order.
========================================================================
select employee_id,
       first_name,
       last_name,
       department_id,
       salary
from (select *, avg(salary) over(partition by department_id) as avg_salary
      from employees) a
where salary<avg_salary
order by employee_id
============================================================================
Q3. Same salaries
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Description:

A company wants to divide the employees into teams such that all the members of each team have the same salary. The teams should follow these criteria:

Each team should consist of at least two employees.
All the employees on a team should have the same salary.
All the employees with the same salary should be assigned to the same team.
If an employee's salary is unique, we do not assign this employee to any team.
A team's ID is assigned based on the rank of the team's salary relative to the other teams' salaries, where the team with the lowest salary has team_id = 1.
Note that the salaries for employees not on a team are not included in this ranking.
Write a query to get the team_id of each employee that is in a team.

Return the result table ordered by team_id in ascending order. In case of a tie, order it by employee_id in ascending order.
====================================================================================

select *, dense_rank() over(order by salary) as team_id
from employees
where salary not in(select salary from employees
                    group by salary
                    having count(*) =1)
order by team_id,employee_id
========================================================================================

. The Most Recent Three Orders
SQL
Unsolved
feature icon
Using hints except Complete Solution is Penalty free now
Use Hint
Problem Statement:

Write a query to find the most recent three orders of each user. If a user ordered three or less than three orders, return all of their orders.

Return the result table ordered by customer_name in ascending order and in case of a tie by the customer_id in ascending order. If there is still a tie, order them by order_date in descending order.
========================================================================
select customer_name, customer_id, order_id, order_date
from (select c.name as customer_name,
             c.customer_id as customer_id, 
             o.order_id as order_id, 
             o.order_date as order_date, 
             rank() over(partition by customer_id order by order_date desc) as rnk
             from orders o 
             join customers c 
             on o.customer_id = c.customer_id) a
where rnk<=3
order by customer_name asc,order_date desc
================================================================================

















